.TH al_init_user_event_source 3 "" "Allegro reference manual"
.SH NAME
.PP
al_init_user_event_source - Allegro 5 API
.SH SYNOPSIS
.IP
.nf
\f[C]
#include\ <allegro5/allegro.h>

void\ al_init_user_event_source(ALLEGRO_EVENT_SOURCE\ *src)
\f[]
.fi
.SH DESCRIPTION
.PP
Initialise an event source for emitting user events.
The space for the event source must already have been allocated.
.PP
One possible way of creating custom event sources is to derive other
structures with ALLEGRO_EVENT_SOURCE at the head, e.g.
.IP
.nf
\f[C]
typedef\ struct\ THING\ THING;

struct\ THING\ {
\ \ \ \ ALLEGRO_EVENT_SOURCE\ event_source;
\ \ \ \ int\ field1;
\ \ \ \ int\ field2;
\ \ \ \ /*\ etc.\ */
};

THING\ *create_thing(void)
{
\ \ \ \ THING\ *thing\ =\ malloc(sizeof(THING));

\ \ \ \ if\ (thing)\ {
\ \ \ \ \ \ \ \ al_init_user_event_source(&thing->event_source);
\ \ \ \ \ \ \ \ thing->field1\ =\ 0;
\ \ \ \ \ \ \ \ thing->field2\ =\ 0;
\ \ \ \ }

\ \ \ \ return\ thing;
}
\f[]
.fi
.PP
The advantage here is that the THING pointer will be the same as the
ALLEGRO_EVENT_SOURCE pointer.
Events emitted by the event source will have the event source pointer as
the \f[C]source\f[] field, from which you can get a pointer to a THING
by a simple cast (after ensuring checking the event is of the correct
type).
.PP
However, it is only one technique and you are not obliged to use it.
.PP
The user event source will never be destroyed automatically.
You must destroy it manually with al_destroy_user_event_source(3).
.SH SEE ALSO
.PP
ALLEGRO_EVENT_SOURCE(3), al_destroy_user_event_source(3),
al_emit_user_event(3), ALLEGRO_USER_EVENT(3)
