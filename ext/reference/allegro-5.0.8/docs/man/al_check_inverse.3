.TH al_check_inverse 3 "" "Allegro reference manual"
.SH NAME
.PP
al_check_inverse - Allegro 5 API
.SH SYNOPSIS
.IP
.nf
\f[C]
#include\ <allegro5/allegro.h>

int\ al_check_inverse(const\ ALLEGRO_TRANSFORM\ *trans,\ float\ tol)
\f[]
.fi
.SH DESCRIPTION
.PP
Checks if the transformation has an inverse using the supplied
tolerance.
Tolerance should be a small value between 0 and 1, with 1e-7 being
sufficient for most applications.
.PP
In this function tolerance specifies how close the determinant can be to
0 (if the determinant is 0, the transformation has no inverse).
Thus the smaller the tolerance you specify, the "worse" transformations
will pass this test.
Using a tolerance of 1e-7 will catch errors greater than 1/1000\[aq]s of
a pixel, but let smaller errors pass.
That means that if you transformed a point by a transformation and then
transformed it again by the inverse transformation that passed this
check, the resultant point should less than 1/1000\[aq]s of a pixel away
from the original point.
.PP
Note that this check is superfluous most of the time if you never
touched the transformation matrix values yourself.
The only thing that would cause the transformation to not have an
inverse is if you applied a 0 (or very small) scale to the
transformation or you have a really large translation.
As long as the scale is comfortably above 0, the transformation will be
invertible.
.PP
\f[I]Parameters:\f[]
.IP \[bu] 2
trans - Transformation to check
.IP \[bu] 2
tol - Tolerance
.PP
\f[I]Returns:\f[] 1 if the transformation is invertible, 0 otherwise
.SH SEE ALSO
.PP
al_invert_transform(3)
