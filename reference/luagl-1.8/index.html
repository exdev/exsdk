<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html xmlns:v="urn:schemas-microsoft-com:vml" xmlns:o="urn:schemas-microsoft-com:office:office">

<head>
<title>LuaGL: OpenGL binding for Lua 5 </title>
<meta http-equiv="Content-Language" content="en-us">
<link rel="stylesheet" type="text/css" href="style.css">
<style type="text/css">
.style2 {
	border-width: 0;
}
.style5 {
	font-size: large;
}
.style6 {
	font-size: medium;
}
.hist_new {
	color: #0000FF;
	font-weight: bold;
}
  .hist_changed {
	color: #008000;
	font-weight: bold;
}
  .hist_fixed {
	color: #FF0000;
	font-weight: bold;
}
  </style>
</head>

<body bgcolor="#FFFFFF">

<a name=top></a>
<center>
<table summary="LuaGL logo" border=0 cellspacing=0 cellpadding=0>
<tr><td align=center class="style2">
<a href="http://www.lua.org">
<img border=0 alt="LuaGL" src="luagl.gif">
</a></td>
<tr><td align=center valign=top class="style2">
	<span class="style5">
	<strong>OpenGL binding for Lua 5.1 and 5.2<br>
	</strong></span><span class="style6"><a href="http://luagl.sourceforge.net">
	http://luagl.sourceforge.net</a></span></td>
</table>
</center>

<p align=center>
<a href="#whatis">About</a> &middot;
<a href="#History">History</a> &middot;
<a href="#howitworks">Usage</a> &middot;
<a href="#ref">Reference</a><hr>

<h2><a name=whatis>What is it LuaGL? </a></h2><p>

It’s a library that provides access to all of the OpenGL (up to version 1.3) functionality from <a href="http://www.lua.org">Lua</a>.<h2><a name=opengl>What is OpenGL? </a></h2><p>

OpenGL is a portable software interface to graphics hardware. More information about OpenGL can be obtained from <a href="http://www.opengl.org">http://www.opengl.org</a>. You can find good tutorials about learning OpenGL at <a href="http://nehe.gamedev.net">http://nehe.gamedev.net</a>. 

<h2><a name=port>Portability</a></h2><p>

That library should run in all systems that support OpenGL. 

<h2><a name=license>License</a></h2><p> 

LuaGL is a free software and uses the MIT License (the same License as Lua). It  can be  used at no cost for both academic and commercial purposes. 

<h2><a name=down>Download</a></h2><p>

You can download LuaGL from the <a href="http://sourceforge.net/projects/luagl/files">SourceForge</a>&nbsp;files page. <p>

LuaGL also needs that you have the OpenGL library installed. All modern 
operating systems already have it, see
<a href="http://www.opengl.org/documentation/implementations/">OpenGL Platform &amp; 
OS Implementations</a>.<h2>Support</h2>
<p>The official support mechanism is by e-mail, using <a href="mailto:scuri@tecgraf.puc-rio.br">scuri@tecgraf.puc-rio.br</a>.</p>
<p>We host the <strong>LuaGL</strong> support features at <strong>SourceForge</strong>:
<a href="http://sourceforge.net/projects/luagl/">
http://sourceforge.net/projects/luagl/</a>. It provides us CVS Repository 
and Downloads.</p>
<h2>Maintainer</h2>
<ul>
	<li>Antonio Scuri</li>
</ul>

<h2>Authors</h2>
<ul>
	<li>Fabio Guerra</li>
	<li>Cleyde Marlyse</li>
</ul>

<h2>To Do</h2>
<ul>
	<li>implement the tessellation functions in GLU</li>
	<li>improve support for OpenGL 1.2 and 1.3</li>
</ul>

<h2>Samples</h2>
<p>Since this distribution does not include the GLUT binding, all the samples 
are based on the <a href="http://www.tecgraf.puc-rio.br/iup">IUP</a> toolkit. 
One sample uses <a href="http://www.tecgraf.puc-rio.br/im">IM</a> to display an 
image. You can browse the samples here: <a href="examples">examples</a>.</p>

<hr>

<h2><a name="History">History</a></h2>

<h3>1.8 - 27 Jun 2012</h3>
<ul>
	<li>
		<span class="hist_changed">Changed:</span> Split luagl into luagl and 
		luagl_base, so luaglu and luagl both depends on luagl_base. And luaglu 
		does not depends on luagl anymore.</li>
	<li>
		<span class="hist_fixed">Fixed:</span> gl.GetTexImage when target is 
		GL_TEXTURE_2D. Thanks to William Adams.</li>
</ul>

<h3>1.7 - 22 Dec 2011</h3>
<ul>
	<li>
		<span class="hist_new">New:</span> support for Lua 5.2. </li>
	<li>
		<span class="hist_fixed">Fixed:</span> viewport parameter in glu.Project, 
		glu.UnProject and nurb:LoadSamplingMatrices. Thanks to Joerg Schlegel.</li>
</ul>

<h3>1.6 - 12 Nov 2010</h3>
<ul>
	<li>
		<span class="hist_new">New:</span> functions gl.NewData and gl.FreeData.</li>
	<li>
		<span class="hist_changed">Changed:</span> libraries names in UNIX now 
		uses the standard &quot;lib&quot; prefix again. Added installation scripts to copy 
		the libraries to the system directories and made links in the Lua 
		installation directory.</li>
	<li>
		<span class="hist_fixed">Fixed:</span> documentation of functions that 
		need a 2D array or a table of tables. Improved error check and report in 
		those functions.</li>
</ul>

<h3>1.5 - 13 Sep 2010</h3>
<ul>
	<li><span class="hist_new">New:</span> functions glu.ScaleImage, glu.Project, 
	glu.UnProject, glu.BuildMipmaps and 
	glu.Build1DMipmaps.</li>
	<li><span class="hist_new">New:</span> sample that loads a texture using IM.</li>
	<li><span class="hist_changed">Changed:</span> glu.Build2DMipmaps now 
	accepts also parameters in a more compatible way.</li>
	<li>
		<span class="hist_fixed">Fixed:</span> nurb:LoadSamplingMatrices to 
	parse matrices tables staring at 1.</li>
</ul>
<h3><a href="https://sourceforge.net/projects/luagl/files/1.4/">1.4</a> - 22 Jun 2010</h3>
<ul>
	<li><span class="hist_new">New:</span> functions gl.GetSelectBuffer and gl.FreeSelectBuffer. (Thanks to 
	J.-F. Cap)</li>
	<li><span class="hist_new">New:</span> quadrics and NURBS functions in GLU 
	implemented as metatables with garbage collection. 
	All methods returns self, so chaining can be done, for ex: 
	&quot;quad:DrawStyle(glu.FILL):Normals(glu.SMOOTH):Cylinder(base, 0.0, height, 
	slices, stacks)&quot;.&nbsp; (Thanks to J.-F. Cap)</li>
	<li><span class="hist_changed">Changed:</span> 
    table return to optimize table creation and proper value type.</li>
	<li><span class="hist_changed">Changed:</span> 
    code to use luaL_check* functions to improve error report.</li>
	<li><span class="hist_changed">Changed:</span> site moved to SourceForge.</li>
	<li>
		<span class="hist_fixed">Fixed:</span> enum parameters parsing.</li>
	<li>
		<span class="hist_fixed">Fixed:</span> missing return value in gl.RenderMode. (Thanks to J.-F. Cap)</li>
	<li>
		<span class="hist_fixed">Fixed:</span> gl.SelectBuffer so given buffer is not freed after return. Buffer 
	is now returned as light user data. (Thanks to J.-F. Cap)</li>
	<li>
		<span class="hist_fixed">Fixed:</span> gl.Bitmap, bad stack index used for bitmap data. Data now can also 
	be nil to only shift the raster position. (Thanks to J.-F. Cap)</li>
	<li>
		<span class="hist_fixed">Fixed:</span> dynamic library name in UNIX.</li>
</ul>

<h3><a href="https://sourceforge.net/projects/luagl/files/1.3/">1.3</a> - 14 Aug 2009</h3>
<ul>
	<li>New site at LuaForge</li>
	<li>New samples using IUP</li>
	<li>Several fixes in the documentation</li>
	<li>Fixed gl.ReadPixels</li>
	<li>Added support for a few GLU functions available in the 1.02-beta</li>
	<li>Added support for raw image data in gl.BitmapRaw, gl.DrawPixelsRaw, gl.GetTexImageRaw, 
	gl.ReadPixelsRaw, gl.TexImage1D, gl.TexImage2D, gl.TexSubImage1D and 
	gl.TexSubImage2D</li>
</ul>

<h3>1.2 - 26 May 2008 (internal release at Tecgraf)</h3>
<ul>
	<li>Build from LuaGL 1.02-beta in SVN</li>
	<li>GLU not supported</li>
	<li>Removed the GLUT binding</li>
	<li>OpenGL constants can now also be used as numbers</li>
	<li>Fixed DLL exports to enable require&quot;luagl&quot;</li>
</ul>

<h3><a href="https://sourceforge.net/projects/luagl/files/1.02/">1.02</a>-SVN and Previous
<a href="https://sourceforge.net/projects/luagl/files/1.01/">1.01</a></h3>
<ul>
	<li>See the old <a href="history_old.txt">History</a>.</li>
</ul>

<hr>
<h2><a name=howitworks>Usage</a></h2>
<p>

This library works as a binding for all OpenGL commands, so you can have full access to the graphics hardware from Lua. <p>

To have access the GL functions in Lua call require&quot;luagl&quot;, or from a C host program you 
could call the &#39;luaopen_luagl&#39; function.

This will create a name space called &#39;gl&#39;, and all the functions and constants 
will be inside of it. <p>

To have access the GLU functions in Lua call require&quot;luaglu&quot;, or from a C host program you 
could call the &#39;luaopen_luaglu&#39; function.

This will create a name space called &#39;glu&#39;, and all the functions and constants 
will be inside of it.<p>

Read the LINSTALL file for instructions on how to install the libraries on 
Linux.<p>

Although the <strong>luagl</strong> and <strong>luaglu</strong> libraries have 
'51' and '52' suffixes they can be removed, by manually renaming the respective 
files. The only file that must retain its original name is the <strong>
luagl_base</strong> library. This is valid for Windows and Linux. <strong>
luagl_base</strong> is not a Lua module. (Since 1.8)<h3><a name=constants>Constants</a></h3><p>

All OpenGL constants were also converted to strings, for example: instead of writing 
gl.QUADS, you can write 'QUADS'. Functions that expected a bitwise operation between mask parameters 
can receive a string that contains all the constants strings separated by comma (,). For example:  
<pre>gl.Begin(gl.TRIANGLES)  or  gl.Begin("TRIANGLES")
gl.Clear(gl.COLOR_BUFFER_BIT+gl.DEPTH_BUFFER_BIT)  or  gl.Clear('COLOR_BUFFER_BIT,DEPTH_BUFFER_BIT') </pre>
<p>OpenGL constants can be used as numbers using gl.XXX 
notation, where XXX is the constant name after &quot;GL_&quot; (for example: gl.QUADS). 
This is much faster than using the strings.<h3><a name=argspecs>Arguments</a></h3><p>

The argument specification (e.g., '2d', '3f', '4sv') at the end of most OpenGL functions names have been removed. For example the new gl.Light function binds the OpenGL functions: glLightf, glLightfv, glLighti, glLightiv. <p>

The number of parameters defines the correct function to use. And it is always used the floating point version of the functions, with the highest possible precision.<p>

Some functions that have a type parameter simply use the most precise possible 
(usually GL_DOUBLE or GL_FLOAT) and the parameter is not used. When stride is 
not used, then it is assumed to be 0.<p>

Whenever is possible, GLboolean is mapped to boolean in Lua.<h3><a name=color>Color and Vector 
Data</a></h3><p>

The color and the vector data can be represented by a lua array. A vector can 
have 2, 3 or 4 values (x, y, z, w), and colors can have 3 or 4 values (red, 
green, blue, alpha). <p>

For example: 
<pre>v1 = { 0, 0 } 
v2 = { 1, 1 } 
Yellow = { 1, 1, 0 } 
gl.Color(Yellow) 
gl.Vertex(v1) 
gl.Vertex(v2) </pre>
<p>
you can also do: 
<pre>gl.Color(1, 1, 0) 
gl.Vertex(0, 0) 
gl.Vertex(1, 1) </pre>

<h3><a name=argtypes>Array Data</a></h3><p>

Arrays are handled as tables or as userdata. For example:<pre>gl.DrawPixels (width, height, format, pixelsArray) -&gt; none 
gl.DrawPixelsRaw (width, height, format, type, pixelsUserData) -&gt; none</pre>
<p>Using userdata is more efficient and less memory consuming, especially for 
large data. But individual values can NOT be accessed.</p>
<p>Some functions use a table that contains secondary tables, like in a 2D 
array. For example:</p>
<pre>v1 = { -1, -1 } 
v2 = {  1, -1 } 
v3 = {  1,  1 } 
v4 = { -1,  1 } 

vertices  = { v1, v2, v3, v4 } 

gl.VertexPointer(vertices) </pre>
<p>This function in particular accepts also a simple array as parameter, but 
must specify the number of elements of the secondary table:</p>
<pre>vertices  = { -1, -1, 1, -1, 1, 1, -1, 1} 

gl.VertexPointer(vertices, 2)</pre>
<p>This function also needs to keep its memory allocated after the call. So to 
release this internal memory you must call:</p>
<pre>gl.VertexPointer(nil)</pre>
<h3><a name=reqinfo>Returned Data</a></h3>
<p>

The functions that request information from OpenGL, will now return the data by the function return value. For example: 
<pre>pixelsArray = gl.GetTexImage(target, level, format) </pre>
<p>

For more information about functions names and parameters, see the Function Reference bellow. 

<h3><a name=bitpattern>Bit Pattern</a></h3><p>

Functions that expects a number with a bit pattern, will accept a string with the mask numbers. All characters that are different to ‘0’ and ‘1’ will be ignored. For example: 
<pre>gl.LineStipple(1, "1111000011110000") 
gl.LineStipple(1, "1010.0101.1000.1111") 
gl.LineStipple(1, &quot;0000 0000 1111 1111&quot;) </pre>

<hr>
<h2><a name=ref>Function Reference</a> (GL)</h2>
<pre>gl.Accum (op, value) -> none 

gl.AlphaFunc (func, ref) -> none 

gl.AreTexturesResident (texturesArray) -> residencesArray 

gl.ArrayElement (i) -> none 

gl.Begin (mode) -> none 

gl.BindTexture (target, texture) -> none 

gl.Bitmap (xorig, yorig, xmove, ymove [, bitmapArray2]) -> none
gl.BitmapRaw (width, height, xorig, yorig, xmove, ymove, bitmapUserData) -&gt; none 

gl.BlendFunc (sfactor, dfactor) -> none 

gl.CallList (list) -> none 

gl.CallLists (listArray) -> none 

gl.Clear (mask) -> none 

gl.ClearAccum (red, green, blue, alpha) -> none 

gl.ClearColor (red, green, blue, alpha) -> none 

gl.ClearDepth (depth) -> none 

gl.ClearIndex (c) -> none 

gl.ClearStencil (s) -> none 

gl.ClipPlane (plane, equationArray) -> none 

gl.Color (red, green, blue [, alpha]) -> none 
gl.Color (colorArray) -> none 

gl.ColorMask (red, green, blue, alpha) -> none 

gl.ColorMaterial (face, mode) -> none 

gl.ColorPointer (colorArray2) -> none                  
gl.ColorPointer (colorArray, size) -> none            
gl.ColorPointer (nil) -> none                            (releases internal memory)

gl.CopyPixels (x, y, width, height, type) -> none 

gl.CopyTexImage (level, internalFormat, border, x, y, width[, height]) -> none 

gl.CopyTexSubImage (level, x, y, xoffset, width[, yoffset, height]) -> none 

gl.CullFace (mode) -> none 

gl.DeleteLists (list, range) -> none 

gl.DeleteTextures (texturesArray) -> none 

gl.DepthFunc (func) -> none 

gl.DepthMask (flag) -> none 

gl.DepthRange (zNear, zFar) -> none 

gl.Disable (cap) -> none 

gl.DisableClientState (array) -> none 

gl.DrawArrays (mode, first, count) -> none 

gl.DrawBuffer (mode) -> none 

gl.DrawElements (mode, indicesArray) -> none 

gl.DrawPixels (width, height, format, pixelsArray) -> none 
gl.DrawPixelsRaw (width, height, format, type, pixelsUserData) -&gt; none   

gl.EdgeFlag (flag) -> none 
gl.EdgeFlag (flagArray) -> none

gl.EdgeFlagPointer (flagsArray) -> none 
gl.EdgeFlagPointer (nil) -> none                     (releases internal memory)

gl.Enable (cap) -> none 

gl.EnableClientState (array) -> none 

gl.End () -> none 

gl.EndList () -> none 

gl.EvalCoord (u[, v]) -> none 
gl.EvalCoord (coordArray) -> none 

gl.EvalMesh (mode, i1, i2[,j1, j2]) -> none 

gl.EvalPoint (i[, j]) -> none 

gl.FeedbackBuffer (size, type) -> dataArray 

gl.Finish () -> none 

gl.Flush () -> none 

gl.Fog (pname, param) -> none 
gl.Fog (pname, paramsArray) -> none 

gl.FrontFace (mode) -> none 

gl.Frustum (left, right, bottom, top, zNear, zFar) -> none 

gl.GenLists (range) -> num 

gl.GenTextures (n) -> texturesArray 

gl.Get (pname) -> param1, param2, param3, ...         (not an array, a sequence of parameters)

gl.GetArray (pname) -> paramsArray 

gl.GetConst (pname) -> string 

gl.GetClipPlane (plane) -> equationArray 

gl.GetError () -> error                               (nil if GL_NO_ERROR)

gl.GetLight (light, pname) -> paramsArray 

gl.GetMap (target, query) -> vArray 

gl.GetMaterial (face, pname) -> paramsArray 

gl.GetPixelMap (map) -> valuesArray 

gl.GetPointer (pname, n) -> valuesArray 

gl.GetPolygonStipple () -> maskArray 

gl.GetString (name) -> string 

gl.GetTexEnv (pname) -> paramsArray 

gl.GetTexGen (coord, pname) -> paramsArray 

gl.GetTexImage (target, level, format) -> pixelsArray
gl.GetTexImageRaw (target, level, format, type, pixelsUserData) -&gt; none     

gl.GetTexLevelParameter (target, level, pname) -> param 

gl.GetTexParameter (target, pname) -> paramsArray 

gl.Hint (target, mode) -> none 

gl.Index (c) -> none 

gl.IndexMask (mask) -> none 

gl.IndexPointer (indexArray) -> none 
gl.IndexPointer (nil) -> none                          (releases internal memory)

gl.InitNames () -> none 

gl.InterleavedArrays (format, dataArray) -> none 

gl.IsEnabled (cap) -> true/false 

gl.IsList (list) -> true/false 

gl.IsTexture (texture) -> true/false 

gl.Light (light, pname, param) -> none 
gl.Light (light, pname, paramsArray) -> none 

gl.LightModel (pname, param) -> none 
gl.LightModel (pname, paramsArray) -> none 

gl.LineStipple (factor, pattern) -> none 

gl.LineWidth (width) -> none 

gl.ListBase (base) -> none 

gl.LoadIdentity () -> none 

gl.LoadMatrix (mArray) -> none 

gl.LoadName (name) -> none 

gl.LogicOp (opcode) -> none 

gl.Map (target, u1, u2, pointsArray) -> none 
gl.Map (target, u1, u2, v1, v2, pointsArray2) -> none 

gl.MapGrid (un, u1, u2[, vn, v1, v2]) -> none 

gl.Material (face, pname, param) -> none 

gl.MatrixMode (mode) -> none 

gl.MultMatrix (mArray) -> none 

gl.NewList (list, mode) -> none 

gl.NewData (size) -> UserData                          (auxiliary function to allocate userdata)
gl.FreeData (UserData) -&gt; none  

gl.Normal (nx, ny, nz) -> none 
gl.Normal (nArray) -> none 

gl.NormalPointer (normalArray2) -> none                   
gl.NormalPointer (normalArray, size) -> none            
gl.NormalPointer (nil) -> none                            (releases internal memory)

gl.Ortho (left, right, bottom, top, zNear, zFar) -> none 

gl.PassThrough (token) -> none 

gl.PixelMap (map, valuesArray) -> none 

gl.PixelStore (pname, param) -> none 

gl.PixelTransfer (pname, param) -> none 

gl.PixelZoom (xfactor, yfactor) -> none 

gl.PointSize (size) -> none 

gl.PolygonMode (face, mode) -> none 

gl.PolygonOffset (factor, units) -> none 

gl.PolygonStipple (maskArray2) -> none
gl.PolygonStipple (maskArray) -> none

gl.PopAttrib () -> none 

gl.PopClientAttrib () -> none 

gl.PopMatrix () -> none 

gl.PopName () -> none 

gl.PrioritizeTextures (texturesArray, prioritiesArray) -> none 

gl.PushAttrib (mask) -> none 

gl.PushClientAttrib (mask) -> none 

gl.PushMatrix () -> none 

gl.PushName (GLuint name) -> none 

gl.RasterPos (x, y[, z, w]) -> none 
gl.RasterPos (vArray) -> none 

gl.ReadBuffer (mode) -> none 

gl.ReadPixels (x, y, width, height, format) -> pixelsArray
gl.ReadPixelsRaw (x, y, width, height, format, type, pixelsUserData) -&gt; none    

gl.Rect (x1, y1, x2, y2) -> none 
gl.Rect (v1, v2) -> none 

gl.RenderMode (mode) -> none 

gl.Rotate (angle, x, y, z) -> none 

gl.Scale (x, y, z) -> none 

gl.Scissor (x, y, width, height) -> none 

gl.SelectBuffer (size) -> SelectUserData
gl.GetSelectBuffer(SelectUserData, index) -&gt; value         (return the value of a given index)
gl.FreeSelectBuffer(SelectUserData) -&gt; none  

gl.ShadeModel (mode) -> none 

gl.StencilFunc (func, ref, mask) -> none 

gl.StencilMask (mask) -> none 

gl.StencilOp (fail, zfail, zpass) -> none 

gl.TexCoord (s[, t, r, q]) -> none 
gl.TexCoord (vArray) -> none 

gl.TexCoordPointer (vArray2) -> none              
gl.TexCoordPointer (vArray, size) -> none        
gl.TexCoordPointer (nil) -&gt; none                            (releases internal memory)

gl.TexEnv (pname, param) -> none 
gl.TexEnv (pname, paramsArray) -> none 

gl.TexGen (coord, pname, param) -> none 
gl.TexGen (coord, pname, paramsArray) -> none 

gl.TexImage (level, internalformat, format, pixelsArray) -> none
gl.TexImage (level, internalformat, format, pixelsArray2) -> none
gl.TexImage1D (level, internalformat, width, border, format, type, pixelsUserData) -&gt; none           
gl.TexImage2D (level, internalformat, width, height, border, format, type, pixelsUserData) -&gt; none    

gl.TexParameter (target, pname, param) -> none 
gl.TexParameter (target, pname, paramsArray) -> none 

gl.TexSubImage (level, format, pixelsArray, xoffset[, yoffset]) -> none
gl.TexSubImage (level, format, pixelsArray2, xoffset[, yoffset]) -> none
gl.TexSubImage1D (level, xoffset, width, format, type, pixelsUserData) -&gt; none                     
gl.TexSubImage2D (level, xoffset, yoffset, width, height, format, type, pixelsUserData) -&gt; none   

gl.Translate (x, y, z) -> none 

gl.Vertex (x, y, [z, w]) -> none 
gl.Vertex (vArray) -> none 

gl.VertexPointer (vertexArray2) -> none             
gl.VertexPointer (vertexArray, size) -> none       
gl.VertexPointer (nil) -&gt; none                                 (releases internal memory)

gl.Viewport (x, y, width, height) -> none </pre>

<h2>Function Reference (GLU)</h2>
<pre>glu.BuildMipmaps(components, format, pixelsArray) -&gt; error
glu.BuildMipmaps(components, format, pixelsArray2) -&gt; error
glu.Build1DMipmaps(components, width, format, type, pixelsUserData) -&gt; error            
glu.Build2DMipmaps(components, width, height, format, type, pixelsUserData) -&gt; error    
glu.Build2DMipmaps(textureArray2) -&gt; error                                     (alternative form)
       (table must contain &quot;target&quot;, &quot;format&quot;, &quot;type&quot;, &quot;width&quot;, &quot;height&quot; and &quot;components&quot; fields)
       (and data organized in lines as unnamed tables)
glu.Build3DMipmaps(components, width, height, depth, format, type, pixelsUserData) -&gt; error  

glu.ErrorString(errorCode) -&gt; string 

glu.GetString (name) -&gt; string  

glu.LookAt(Ex, Ey, Ez, Lx, Ly, Lz, Ux, Uy, Uz) -&gt; none 

glu.Ortho2D(left, right, bottom, top) -&gt; none 

glu.Perspective(fovy, aspect, near, far) -&gt; none 

glu.PickMatrix( x, y, deltax, deltay, viewportArray) -&gt; none 

glu.Project(objx, objy, objz, modelMatrixArray, projMatrixArray, viewportArray) -&gt; error, winx, winy, winz 

glu.ScaleImage(format, widthIn, heightIn, pixelsArrayIn, widthOut, heightOut) -&gt; error, pixelsArrayOut
glu.ScaleImageRaw(format, widthIn, heightIn, typeIn, pixelsIn, widthOut, heightOut, typeOut, pixelsUserDataOut) -&gt; error 

glu.NewQuadric() -&gt; quad
quad:Cylinder(base, top, height, slices, stacks) -&gt; quad
quad:Disk(inner, outer, slices, loops) -&gt; quad
quad:PartialDisk (inner, outer, slices, loops, start, sweep) -&gt; quad
quad:DrawStyle(draw) -&gt; quad
quad:Normals(normal) -&gt; quad
quad:Orientation(orientation) -&gt; quad
quad:Texture(texture) -&gt; quad
quad:Sphere(radius, slices, stacks) -&gt; quad

glu.NewNurbsRenderer() -&gt; nurb
nurb:Callback(which, func) -&gt; nurb
nurb:BeginCurve() -&gt; nurb
nurb:BeginSurface() -&gt; nurb
nurb:BeginTrim() -&gt; nurb
nurb:EndCurve() -&gt; nurb
nurb:EndSurface() -&gt; nurb
nurb:EndTrim() -&gt; nurb
nurb:Property(property, value)
nurb:Property(property) -> value
nurb:LoadSamplingMatrices (modelArray, perspectiveArray, viewArray) -&gt; nurb
nurb:Curve(knotsArray, controlArray, type) -&gt; nurb
nurb:Surface(sKnotsArray, tKnotsArray, controlArray2, type) -&gt; nurb
nurb:PwlCurve(dataArray, type) -&gt; nurb

</pre>

<h2>Not Implemented&nbsp; (GL)</h2>
<pre>glInterleavedArrays</pre>

<h2>Not Implemented&nbsp; (GLU)</h2>
<pre>gluQuadricCallback

All the tessellation functions:
gluNextContour
gluBeginPolygon
gluEndPolygon
gluNewTess
gluTessBeginContour
gluTessBeginPolygon
gluTessCallback
gluTessEndContour
gluTessEndPolygon
gluTessNormal
gluTessProperty
gluTessVertex
gluDeleteTess
gluGetTessProperty
</pre>

</body>
</html>
