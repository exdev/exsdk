.TH al_emit_user_event 3 "" "Allegro reference manual"
.SH NAME
.PP
al_emit_user_event - Allegro 5 API
.SH SYNOPSIS
.IP
.nf
\f[C]
#include\ <allegro5/allegro.h>

bool\ al_emit_user_event(ALLEGRO_EVENT_SOURCE\ *src,
\ \ \ ALLEGRO_EVENT\ *event,\ void\ (*dtor)(ALLEGRO_USER_EVENT\ *))
\f[]
.fi
.SH DESCRIPTION
.PP
Emit a user event.
The event source must have been initialised with
al_init_user_event_source(3).
Returns \f[C]false\f[] if the event source isn\[aq]t registered with any
queues, hence the event wouldn\[aq]t have been delivered into any
queues.
.PP
Events are \f[I]copied\f[] in and out of event queues, so after this
function returns the memory pointed to by \f[C]event\f[] may be freed or
reused.
Some fields of the event being passed in may be modified by the
function.
.PP
Reference counting will be performed if \f[C]dtor\f[] is not NULL.
Whenever a copy of the event is made, the reference count increases.
You need to call al_unref_user_event(3) to decrease the reference count
once you are done with a user event that you have received from
al_get_next_event(3), al_peek_next_event(3), al_wait_for_event(3), etc.
.PP
Once the reference count drops to zero \f[C]dtor\f[] will be called with
a copy of the event as an argument.
It should free the resources associated with the event, but \f[I]not\f[]
the event itself (since it is just a copy).
.PP
If \f[C]dtor\f[] is NULL then reference counting will not be performed.
It is safe, but unnecessary, to call al_unref_user_event(3) on
non-reference counted user events.
.SH SEE ALSO
.PP
ALLEGRO_USER_EVENT(3), al_unref_user_event(3)
